<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hadoop2.0完全分布式HA搭建</title>
      <link href="/posts/4175.html"/>
      <url>/posts/4175.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Hadoop2-0-HA搭建步骤"><a href="#1-Hadoop2-0-HA搭建步骤" class="headerlink" title="1    Hadoop2.0 HA搭建步骤"></a>1    Hadoop2.0 HA搭建步骤</h1><p>##1.1    准备工作<br>6台虚拟机，内存512M，hadoop1~6<br>修改静态IP：192.168.65.121 ~ 126<br>##1.2    架构图<br> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://hualei.online/medias/pictures/1.png" alt="1"><br>##1.3    集群节点分配<br>    hadoop1<br>Zookeeper<br>NameNode(active)<br>Resourcemanager (active)<br>    hadoop2<br>Zookeeper<br>NameNode (standby)<br>    hadoop3<br>Zookeeper<br>ResourceManager(standby)<br>    hadoop4<br>DataNode<br>NodeManager<br>JournalNode<br>    hadoop5<br>DataNode<br>NodeManager<br>JournalNode<br>    hadoop6<br>DataNode<br>NodeManager<br>JournalNode<br>##1.4    安装步骤<br>###1.4.1    固化IP<br>修改配置文件<br>cd /etc/sysconfig/network-scripts    #进入网络配置目录<br>dir ifcfg*                                #找到网卡配置文件<br>ifcfg-ens16777736  ifcfg-lo<br>vi ifcfg-ens16777736<br>配置文件内容<br>TYPE=Ethernet<br>BOOTPROTO=static                                    #改成static，针对NAT<br>NAME=eno16777736<br>UUID=4cc9c89b-cf9e-4847-b9ea-ac713baf4cc8<br>DEVICE=eno16777736<br>ONBOOT=yes                    #开机启动此网卡<br>IPADDR=192.168.163.129    #固定IP地址<br>NETMASK=255.255.255.0        #子网掩码<br>GATEWAY=192.168.163.2        #网关和NAT自动配置的相同，不同则无法登录<br>DNS1=192.168.163.2            #和网关相同<br>重启网络<br>service network restart<br>ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p>###1.4.2    永久关闭每台机器的防火墙<br>systemctl stop firewalld.service            #关闭防火墙服务<br>systemctl disable firewalld.service        #禁止防火墙开启启动<br>firewall-cmd –state                        #检查防火墙状态<br>###1.4.3    为每台机器配置主机名*<br>hadoop1,hadoop2 ……<br>以及hosts文件<br>配置主机名<br>执行：vim /etc/hostname 修改为hadoop1~6<br>然后执行 hostname 主机名<br>达到不重启生效目的<br>配置hosts文件<br>执行：vim /etc/hosts<br>示例：<br>127.0.0.1 localhost<br>::1 localhost<br>192.168.65.121 hadoop1<br>192.168.65.122 hadoop2<br>192.168.65.123 hadoop3<br>192.168.65.124 hadoop4<br>192.168.65.125 hadoop5<br>192.168.65.126 hadoop6<br>###1.4.4    为每台机器配置ssh免秘钥登录<br>执行：ssh-keygen<br>ssh-copy-id root@hadoop1 （分别发送到6台节点上）<br>vim /root/.ssh/known_hosts 检查是否配置成功<br>###1.4.5    为每台机器安装jdk和配置JAVA_HOME<br>vim /etc/profile<br>在尾行添加<br>JAVA_HOME=/home/app/jdk1.8.0_65<br>JAVA_BIN=/home/app/jdk1.8.0_65/bin<br>HADOOP_HOME=/home/app/hadoop-2.7.1<br>PATH=$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH<br>CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar<br>export JAVA_HOME JAVA_BIN HADOOP_HOME PATH CLASSPATH</p><p>###1.4.6    前三台机器安装和配置zookeeper<br>解压安装包 tar -xvf zookeeper-3.4.8.tar.gz<br>进入conf目录 cd zookeeper-3.4.8/conf/<br>复制zoo_sample.cfg 为zoo.cfg:  cp zoo_sample.cfg zoo.cfg<br>编辑zoo.cfg：vim zoo.cfg<br> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://hualei.online/medias/pictures/2.png" alt="2"><br> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://hualei.online/medias/pictures/3.png" alt="3"><br> <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://hualei.online/medias/pictures/4.png" alt="4">    </p><p>Zookeeper根目录中创建tmp文件夹，tmp文件夹中创建myid文件，编辑文本：1（2,3）</p><p>拷贝整个zookeeper目录到hadoop2，hadoop3并修改myid文件分别为2,3<br>scp -r zookeeper-3.4.8 hadoop2:/home/app</p><p>###1.4.7    安装和配置01节点的hadoop<br>创建/home/app目录<br>解压安装包<br>###1.4.8    配置hadoop-env.sh<br>cd etc/hadoop<br>配置 hadoop-env.sh<br>vim hadoop-env.sh<br>#JDK安装目录，虽然系统配置了JAVA_HOME，但有时无法正确识别，最后进行配置<br>export JAVA_HOME=/home/app/jdk1.8.0_65<br>#指定hadoop的配置文件目录，不运行hadoop可以不指定<br>export HADOOP_CONF_DIR=/home/app/hadoop-2.7.1/etc/hadoop<br>配置jdk安装所在目录<br>配置hadoop配置文件所在目录<br>###1.4.9    配置core-site.xml<br><configuration></configuration></p><!--用来指定hdfs的老大，ns为固定属性名，表示两个namenode--><property><name>fs.defaultFS</name><value>hdfs://ns</value></property><!--用来指定hadoop运行时产生文件的存放目录--><property><name>hadoop.tmp.dir</name><value>/home/app/hadoop-2.7.1/tmp</value></property><!--执行zookeeper地址--><property><name>ha.zookeeper.quorum</name><value>hadoop1:2181,hadoop2:2181,hadoop3:2181</value></property>###1.4.10    配置01节点的hdfs-site.xml配置<configuration><!--执行hdfs的nameservice为ns,和core-site.xml保持一致--><property><name>dfs.nameservices</name><value>ns</value></property><!--ns下有两个namenode,分别是nn1,nn2--><property><name>dfs.ha.namenodes.ns</name><value>nn1,nn2</value></property><!--nn1 的 RPC 通信地址--><property><name>dfs.namenode.rpc-address.ns.nn1</name><value>hadoop1:9000</value></property><!--nn1的http通信地址--><property><name>dfs.namenode.http-address.ns.nn1</name><value>hadoop1:50070</value></property><!--nn2的RPC通信地址--><property><name>dfs.namenode.rpc-address.ns.nn2</name><value>hadoop2:9000</value></property><!--nn2 的 http 通信地址--><property><name>dfs.namenode.http-address.ns.nn2</name><value>hadoop2:50070</value></property><!--指定namenode的元数据在JournalNode上的存放位置,这样，namenode2可以 从 jn 集群里获取          最新的namenode的信息，达到热备的效果--><property><name>dfs.namenode.shared.edits.dir</name><value>qjournal://hadoop4:8485;hadoop5:8485;hadoop6:8485/ns</value></property><!--指定 JournalNode 存放数据的位置--><property><name>dfs.journalnode.edits.dir</name><value>/home/app/hadoop-2.7.1/journal</value></property><!--开启namenode故障时自动切换--><property><name>dfs.ha.automatic-failover.enabled</name><value>true</value></property><!--配置切换的实现方式--><property><name>dfs.client.failover.proxy.provider.ns</name><value>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider</value></property><!--配置隔离机制--><property><name>dfs.ha.fencing.methods</name><value>sshfence</value></property><!--配置隔离机制的ssh登录秘钥所在的位置--><property><name>dfs.ha.fencing.ssh.private-key-files</name><value>/root/.ssh/id_rsa</value></property><!--配置namenode数据存放的位置,可以不配置，如果不配置，默认用的是          core-site.xml里配置的hadoop.tmp.dir的路径--><property><name>dfs.namenode.name.dir</name><value>file:///home/app/hadoop-2.7.1/tmp/namenode</value></property><!--配置datanode数据存放的位置,可以不配置，如果不配置，默认用的是               core-site.xml 里配置的 hadoop.tmp.dir 的路径--><property><name>dfs.datanode.data.dir</name><value>file:///home/app/hadoop-2.7.1/tmp/datanode</value></property><!--配置 block 副本数量--><property><name>dfs.replication</name><value>3</value></property><!--设置hdfs的操作权限，false表示任何用户都可以在hdfs上操作文件--><property><name>dfs.permissions</name><value>false</value></property></configuration>###1.4.11    配置 mapred-site.xml配置代码：<configuration><property><!--指定mapreduce运行在yarn上--><name>mapreduce.framework.name</name><value>yarn</value></property></configuration>###1.4.12    配置yarn-site.xml配置代码：<configuration><!--开启YARN HA --><property><name>yarn.resourcemanager.ha.enabled</name><value>true</value></property>  <!--指定两个resourcemanager的名称--><property><name>yarn.resourcemanager.ha.rm-ids</name><value>rm1,rm2</value></property><!--配置rm1，rm2的主机--><property><name>yarn.resourcemanager.hostname.rm1</name><value>hadoop1</value></property><property><name>yarn.resourcemanager.hostname.rm2</name><value>hadoop3</value></property><!--开启yarn恢复机制--><property><name>yarn.resourcemanager.recovery.enabled</name><value>true</value></property><!--执行rm恢复机制实现类--><property><name>yarn.resourcemanager.store.class</name><value>org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore</value></property><!--配置zookeeper的地址--><property><name>yarn.resourcemanager.zk-address</name><value>hadoop1:2181,hadoop2:2181,hadoop3:2181</value><description>For multiple zk services, separate them with comma</description></property><!--指定YARN HA的名称--><property><name>yarn.resourcemanager.cluster-id</name><value>yarn-ha</value></property><!--指定 yarn 的老大 resoucemanager 的地址--><property><name>yarn.resourcemanager.hostname</name><value>hadoop1</value></property><!--NodeManager获取数据的方式--><property><name>yarn.nodemanager.aux-services</name><value>mapreduce_shuffle</value></property></configuration>###1.4.13    配置slaves文件配置代码：hadoop4hadoop5hadoop6###1.4.14    根据配置文件，创建相关的文件夹，用来存放对应数据在hadoop-2.7.1目录下创建:①journal目录②创建tmp目录③在tmp目录下，分别创建namenode目录和datanode目录###1.4.15    配置 hadoop 的环境变量（可不配）JAVA_HOME=/home/app/jdk1.8.0_65JAVA_BIN=/home/app/jdk1.8.0_65/binHADOOP_HOME=/home/app/hadoop-2.7.1PATH=$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATHCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME JAVA_BIN HADOOP_HOME PATH CLASSPATH<p>###1.4.16    通过scp 命令，将hadoop安装目录远程copy到其他5台机器上<br>比如向hadoop02节点传输：<br>scp -r hadoop-2.7.1 root@hadoop2:/home/app<br>###1.4.17    启动zookeeper集群<br>在Zookeeper安装目录的bin目录下执行：sh zkServer.sh start<br>sh zkServer.sh status  验证是否启动成功，如成功，两台从节点一台主节点<br>###1.4.18    格式化zookeeper<br>在zk的leader节点上执行：<br>hdfs zkfc -formatZK，这个指令的作用是在zookeeper集群上生成ha节点 （ns节点）<br>注：18–24步可以用一步来替代：进入hadoop安装目录的sbin目录，执行： sh start-dfs.sh 。 但建议还是按部就班来执行，比较可靠。<br>###1.4.19    启动journalnode集群<br>在4、5、6节点上执行：<br>切换到hadoop安装目录的sbin目录下，执行：<br>sh hadoop-daemons.sh start journalnode<br>然后执行jps命令查看进程。<br>###1.4.20    格式化1节点的namenode<br>在1节点上执行：<br>hadoop namenode -format<br>###1.4.21    启动1节点的namenode<br>在 1 节点上执行：<br>sh hadoop-daemon.sh start namenode<br>###1.4.22    把2节点的namenode节点变为standby namenode节点<br>在2节点上执行：<br>hdfs namenode -bootstrapStandby<br>###1.4.23    启动 2 节点的 namenode 节点<br>在2节点上执行：<br>sh hadoop-daemon.sh start namenode<br>###1.4.24    在4,5,6节点上启动datanode节点<br>在 4,5,6 节点上执行： sh hadoop-daemon.sh start datanode<br>###1.4.25    启动zkfc（启动FalioverControllerActive)<br>在1,2节点上执行：<br>sh hadoop-daemon.sh start zkfc<br>###1.4.26    在1节点上启动主Resourcemanager<br>在1节点上执行：start-yarn.sh<br>启动成功后，4,5,6节点上应该有nodemanager 的进程<br>###1.4.27    在 3 节点上启动副 Resoucemanager<br>在3节点上执行：sh yarn-daemon.sh start resourcemanager<br>##1.5    测试<br>输入地址： <a href="http://192.168.65.121:50070" target="_blank" rel="noopener">http://192.168.65.121:50070</a> ，查看 namenode 的信息，是active状态<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://hualei.online/medias/pictures/5.png" alt="5"></p><p>输入地址：<a href="http://192.168.65.122:50070查看namenode的信息，是standby状态" target="_blank" rel="noopener">http://192.168.65.122:50070查看namenode的信息，是standby状态</a><br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://hualei.online/medias/pictures/6.png" alt="6"></p><p>然后停掉01节点的namenode,此时发现standby的namenode变为active。<br>如果出现standby节点不能正确替代active的情况检查fuser是否正常<br>yum provides “*/fuser”</p><p>在启动namenode的两台节点上安装fuser,分别执行<br>yum -y install psmisc</p><p><a href="http://f.dataguru.cn/hadoop-707122-1-1.html" target="_blank" rel="noopener">http://f.dataguru.cn/hadoop-707122-1-1.html</a></p><hr><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://hualei.online/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://hualei.online/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://hualei.online/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> -集群搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -大数据 -Hadoop -技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一招搞定GitHub下载加速!</title>
      <link href="/posts/fdc0.html"/>
      <url>/posts/fdc0.html</url>
      
        <content type="html"><![CDATA[<h1 id="一个痛点"><a href="#一个痛点" class="headerlink" title="一个痛点"></a>一个痛点</h1><p>众所周知，GitHub是一个巨大的开源宝库，以及程序员和编程爱好者的聚集地，包括我之前推荐的诸多优秀的开源项目全部都是位于GitHub上。但是每当我们看到优秀的开源项目，准备去下（bai）载（piao）时，会发现 git clone的速度异常之慢！就我个人而言，在我家里200M移动宽带的环境下，我克隆开源项目就没发现速度大于过 20.00KiB/s的时候，这简直太难受了。</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://hualei.online/medias/pictures/%E5%9B%BE%E7%89%87%E4%B8%80.jpg" alt="图片一"><br>小项目倒还好，我等几分钟无所谓；一旦项目庞大起来，或者项目文件数目一多， git clone 大概率会失败！<br>当然网上常见的诸如修改hosts、代理等方式实际使用效果并不一定好，而且也不稳定。</p><h1 id="码云”是个好东西"><a href="#码云”是个好东西" class="headerlink" title="码云”是个好东西"></a>码云”是个好东西</h1><p>接下来就介绍一种GitHub下载的加速方法：通过国内码云平台的转接，来完成GitHub上项目的下载加速。<br> （1）首先确保码云上有账户，可以正常使用，没有的可以自行注册一下。<br> （2）点击右上角新建仓库的加号 +，选择“从 GitHub/GitLab导入仓库”菜单<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://hualei.online/medias/pictures/%E5%9B%BE%E7%89%87%E4%BA%8C.jpg" alt="图片二"><br>  (3)然后填写位于 GitHub上你想 clone的仓库地址并导入<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://hualei.online/medias/pictures/%E5%9B%BE%E7%89%87%E4%B8%89.jpg" alt="图片三"><br>这一步交给码云来做速度是非常快的，一会儿功夫，码云就克隆出了一份和GitHub上一模一样的项目！<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://hualei.online/medias/pictures/%E5%9B%BE%E7%89%87%E5%9B%9B.jpg" alt="图片四"><br>  (4）接下来我们通过码云上的项目地址，将项目 clone到本地，这时候的clone速度就很快了，几 MB/s的速度是没问题的，很快项目就下载下来了。按道理讲这时候我们的目的已经达到了，不过不要忘了，还有一件事没做。</p><hr><h1 id="重新关联远端地址"><a href="#重新关联远端地址" class="headerlink" title="重新关联远端地址"></a>重新关联远端地址</h1><p>要知道，这时候克隆到本地的项目关联的是码云Gitee的地址，已经和原来的GitHub项目完全脱离了，是另外一个副本。<br>在必要情况下（比如我们就是要给GitHub上的某个项目提 PR），我们还需要重新将我们本地的项目关联到原来的GitHub项目上去，做法如下：<br> （1）首先找到位于本地仓库目录下的隐藏文件夹 .git<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://hualei.online/medias/pictures/%E5%9B%BE%E7%89%87%E4%BA%94.jpg" alt="图片五"><br> （2）用文本编辑器打开 .git文件夹中的 config配置文件<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://hualei.online/medias/pictures/%E5%9B%BE%E7%89%87%E5%85%AD.jpg" alt="图片六"><br>  (3)将配置文件中的 [remote “origin”].url字段重新关联到原来位于GitHub上的GitHub项目地址<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://hualei.online/medias/pictures/%E5%9B%BE%E7%89%87%E4%B8%83.jpg" alt="图片七"><br>当然你也可以通过命令行来修改远端地址，效果一样的<br>至此大功告成，本地项目就相当于是 clone自GitHub，后续提代码，提 PR到GitHub上都没有问题。</p><hr><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://hualei.online/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://hualei.online/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://hualei.online/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL分库分表方案汇总</title>
      <link href="/posts/fd29.html"/>
      <url>/posts/fd29.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、数据库瓶颈"><a href="#一、数据库瓶颈" class="headerlink" title="一、数据库瓶颈"></a>一、数据库瓶颈</h1><p>不管是IO瓶颈，还是CPU瓶颈，最终都会导致数据库的活跃连接数增加，进而逼近甚至达到数据库可承载活跃连接数的阈值。在业务Service来看就是，可用数据库连接少甚至无连接可用。接下来就可以想象了吧（并发量、吞吐量、崩溃）。</p><h2 id="1、IO瓶颈"><a href="#1、IO瓶颈" class="headerlink" title="1、IO瓶颈"></a>1、IO瓶颈</h2><p>第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度 -&gt; 分库和垂直分表。<br>第二种：网络IO瓶颈，请求的数据太多，网络带宽不够 -&gt; 分库。</p><h2 id="2、CPU瓶颈"><a href="#2、CPU瓶颈" class="headerlink" title="2、CPU瓶颈"></a>2、CPU瓶颈</h2><p>第一种：SQL问题，如SQL中包含join，group by，order by，非索引字段条件查询等，增加CPU运算的操作 -&gt; SQL优化，建立合适的索引，在业务Service层进行业务计算。<br>第二种：单表数据量太大，查询时扫描的行太多，SQL效率低，CPU率先出现瓶颈 -&gt; 水平分表。</p><hr><h1 id="二、分库分表"><a href="#二、分库分表" class="headerlink" title="二、分库分表"></a>二、分库分表</h1><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://hualei.online/medias/pictures/%E6%95%B0%E6%8D%AE%E5%BA%931.jpg" alt="数据库1"></p><h2 id="1、水平分库"><a href="#1、水平分库" class="headerlink" title="1、水平分库"></a>1、水平分库</h2><p>概念：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。</p><p>结果：<br>每个库的结构都一样；<br>每个库的数据都不一样，没有交集；<br>所有库的并集是全量数据；</p><p>场景：系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。<br>分析：库多了，io和cpu的压力自然可以成倍缓解。</p><h2 id="2、水平分表"><a href="#2、水平分表" class="headerlink" title="2、水平分表"></a>2、水平分表</h2><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://hualei.online/medias/pictures/%E6%95%B0%E6%8D%AE%E5%BA%932.jpg" alt="数据库2"><br>概念：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。</p><p>结果：<br>每个表的结构都一样；<br>每个表的数据都不一样，没有交集；<br>所有表的并集是全量数据；<br>场景：系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。推荐：一次SQL查询优化原理分析<br>分析：表的数据量少了，单次SQL执行效率高，自然减轻了CPU的负担。</p><h2 id="3、垂直分库"><a href="#3、垂直分库" class="headerlink" title="3、垂直分库"></a>3、垂直分库</h2><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://hualei.online/medias/pictures/%E6%95%B0%E6%8D%AE%E5%BA%933.jpg" alt="数据库3"><br>概念：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。</p><p>结果：<br>每个库的结构都不一样；<br>每个库的数据也不一样，没有交集；<br>所有库的并集是全量数据；<br>场景：系统绝对并发量上来了，并且可以抽象出单独的业务模块。<br>分析：到这一步，基本上就可以服务化了。例如，随着业务的发展一些公用的配置表、字典表等越来越多，这时可以将这些表拆到单独的库中，甚至可以服务化。再有，随着业务的发展孵化出了一套业务模式，这时可以将相关的表拆到单独的库中，甚至可以服务化。</p><h2 id="4、垂直分表"><a href="#4、垂直分表" class="headerlink" title="4、垂直分表"></a>4、垂直分表</h2><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://hualei.online/medias/pictures/%E6%95%B0%E6%8D%AE%E5%BA%934.jpg" alt="数据库4"><br>概念：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。</p><p>结果：<br>每个表的结构都不一样；<br>每个表的数据也不一样，一般来说，每个表的字段至少有一列交集，一般是主键，用于关联数据；<br>所有表的并集是全量数据；<br>场景：系统绝对并发量并没有上来，表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈。<br>分析：可以用列表页和详情页来帮助理解。垂直分表的拆分原则是将热点数据（可能会冗余经常一起查询的数据）放在一起作为主表，非热点数据放在一起作为扩展表。这样更多的热点数据就能被缓存下来，进而减少了随机读IO。拆了之后，要想获得全部数据就需要关联两个表来取数据。<br>但记住，千万别用join，因为join不仅会增加CPU负担并且会讲两个表耦合在一起（必须在一个数据库实例上）。关联数据，应该在业务Service层做文章，分别获取主表和扩展表数据然后用关联字段关联得到全部数据。</p><hr><h1 id="三、分库分表工具"><a href="#三、分库分表工具" class="headerlink" title="三、分库分表工具"></a>三、分库分表工具</h1><p>1.sharding-sphere：jar，前身是sharding-jdbc；<br>2.TDDL：jar，Taobao Distribute Data Layer；<br>3.Mycat：中间件。<br>    注：工具的利弊，请自行调研，官网和社区优先。</p><h1 id="四、分库分表步骤"><a href="#四、分库分表步骤" class="headerlink" title="四、分库分表步骤"></a>四、分库分表步骤</h1><p>根据容量（当前容量和增长量）评估分库或分表个数 -&gt; 选key（均匀）-&gt; 分表规则（hash或range等）-&gt; 执行（一般双写）-&gt; 扩容问题（尽量减少数据的移动）。<br>扩展：MySQL：分库分表与分区的区别和思考</p><h1 id="五、分库分表总结"><a href="#五、分库分表总结" class="headerlink" title="五、分库分表总结"></a>五、分库分表总结</h1><p>分库分表，首先得知道瓶颈在哪里，然后才能合理地拆分（分库还是分表？水平还是垂直？分几个？）。且不可为了分库分表而拆分。<br>选key很重要，既要考虑到拆分均匀，也要考虑到非partition key的查询。<br>只要能满足需求，拆分规则越简单越好。</p><hr><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://hualei.online/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://hualei.online/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://hualei.online/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> IT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot框架的使用</title>
      <link href="/posts/7c5b.html"/>
      <url>/posts/7c5b.html</url>
      
        <content type="html"><![CDATA[<h1 id="简短介绍"><a href="#简短介绍" class="headerlink" title="简短介绍"></a>简短介绍</h1><p>概述<br>随着动态语言的流行（Ruby、Groovy、Scala、Node.js），Java的开发显得格外的笨重：繁多的配置、低下的开发效率、复杂的部署流程以及第三方技术集成难度大。<br>在上述环境下，Springboot应运而生。它使用”习惯优于配置”（项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须手动进行配置）的理念让你的项目快速运行起来。使用springboot很容易创建一个独立运行（运行jar，内嵌servlet容器）、准生产级别的基于Spring框架的项目，使用springboot你可以不用或者只需要很少的Spring配置。</p><hr><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>SpringBoot 入门实例<br>Spring Boot 的核心功能<br>独立运行的Spring项目<br>Spring Boot可以以jar包的形式独立运行，运行一个Spring Boot项目只需要通过java -jar xx.jar。<br>内置Servlet容器<br>Spring Boot可选择内嵌Tomcat、Jetty或者Undertow，这样无须以war包形式部署。<br>提供starter简化maven配置<br>Spring提供了一系列的starter pom来简化maven依赖加载，例如：当你使用了spring-boot-starter-web时，会自动加入相关依赖，无需你手动一个一个的添加坐标依赖。<br>自动配置Spring<br>Spring Boot会根据在类路径中的jar包、类，为jar包里的类自动配置Bean，这样会极大地减少我们要使用的配置。当然，Spring Boot只是考虑了大多数的开发场景，并不是所有场景，若在实际开发中，我们需要自动配置bean，而Spring Boot没有提供支持，则可以自定义自动配置。<br>无代码生成和xml配置<br>Spring Boot的神奇的不是借助于代码生成来实现的，而是通过条件注解来实现的，这是Spring 4.x提供的新特性，Spring 4.x提倡使用java配置和注解配置相结合，而Spring Boot不需要任何xml配置即可实现Sping Boot的所有配置。<br>优缺点</p><p>优点<br>快速构建项目：省略了繁琐且重复的xml配置，分分钟构建一个web工程；<br>对主流开发框架的无配置集成：提供了很多Starter 依赖包，开箱即用，无需多余配置；<br>项目可独立运行：无需外部依赖Servlet容器；<br>极大地提供了开发、部署效率；<br>监控简单：提供了actuator包，可以使用它来对你的应用进行监控。</p><p>缺点<br>依赖太多：一个简单的SpringBoot应用都有好几十M只有；<br>缺少监控集成方案、安全管理方案：只提供基础监控，要实现生产级别的监控，监控方案需要自己动手解决；(后期讲解soringCloud时，会结合pinpoint和skywalking分布式链路工具进行应用监控)</p><hr><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>正文<br>在 eclips e中创建 maven project，创建过程中不使用 archetype，packaging 属性默认 jar 即可。<br>pom.xml 中添加 SpringBoot 依赖<br><parent><br>    <groupid>org.springframework.boot</groupid><br>    <artifactid>spring-boot-starter-parent</artifactid><br>    <version>2.0.2.RELEASE</version><br></parent></p><dependencies>    <dependency>        <groupid>org.springframework.boot</groupid>        <artifactid>spring-boot-starter-web</artifactid>    </dependency></dependencies>在 src/main/java 下创建基础包，本文为 com.aotian.demo，然后创建一个启动类，本文创建为 SpringBootDemo，这个类用于启动 SpringBoot 内置容器，可以理解为 SpringBoot 程序的入口，SpringBoot 会扫描这个类所在包的所有子包中的内容。创建后添加 main 方法和注解,代码如下：package com.aotian.demo;<p>import org.springframework.boot.SpringApplication;<br>import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</p><p>/**</p><ul><li><p>springboot启动程序</p></li><li><p>@author aotian</p></li><li></li><li><p>/<br>@SpringBootApplication<br>public class SpringBootDemo {</p><p>  public static void main(String[] args) {</p><pre><code>  SpringApplication.run(SpringBootDemo.class, args);</code></pre><p>  }</p></li></ul><p>}<br>在上一步的基础包下继续创建子包，本文创建的是 controller 包，然后创建具体的业务类，本文创建为 DemoController，其中代码与 SpringMVC 写法一样，代码如下：<br>package com.aotian.demo.controller;</p><p>import org.springframework.web.bind.annotation.RequestMapping;<br>import org.springframework.web.bind.annotation.RestController;</p><p>/**</p><ul><li><p>演示项目控制类</p></li><li><p>@author aotian</p></li><li></li><li><p>/<br>@RestController<br>public class DemoController {</p><p>  @RequestMapping(“/helloSpringBoot”)<br>  public String helloSpringBoot() {</p><pre><code>  return "Hello Spring Boot";</code></pre><p>  }</p></li></ul><p>}<br>启动 SpringBoot 程序。返回之前的 SpringBootDemo 类中运行 main 方法，可在控制台看到如下内容，其中红线标注的部分提示到：<br>springmvc 默认访问地址为 /<br>tomcat 默认端口为 8080<br>springboot 程序启动成功</p><p>spring boot 启动页面<br>在浏览器中输入 <a href="http://localhost:8080/helloSpringBoot" target="_blank" rel="noopener">http://localhost:8080/helloSpringBoot</a> 即可在浏览器中查看其返回的字符串。</p><p>到此，一个简单的Spring Boot程序就开发完了，与Spring MVC 的开发效率比较起来，那一定是一个跨时代的飞跃，减少了烦人的XML配置文件，这样程序看起来就会轻松很多。</p><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://hualei.online/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://hualei.online/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://hualei.online/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术的学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 技术 </tag>
            
            <tag> IT </tag>
            
            <tag> 程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客开源</title>
      <link href="/posts/be38.html"/>
      <url>/posts/be38.html</url>
      
        <content type="html"><![CDATA[<h1 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h1><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://raw.githubusercontent.com/shw2018/cdn/master/blog_files/img/Blog-Open-Source/blog-demo1.gif" alt="演示Demo"></p><h1 id="简短介绍"><a href="#简短介绍" class="headerlink" title="简短介绍"></a>简短介绍</h1><p>倒腾了一两周总算把个人博客网站完善了，目前这个版本使用应该是够了，当然还有一些优化项和功能增加后续在慢慢更新.</p><p>本博客基于<code>Hexo</code>框架搭建，用到<a href="https://github.com/hualei1234567" target="_blank" rel="noopener">hexo-theme-matery</a>主题, 并在此基础之上做了很多修改，修复了一些bug，增加了一些新的特性和功能，博客地址：<a href="https://hualei1234567.github.io/" target="_blank" rel="noopener">https://hualei1234567.github.io</a>，博客演示：<a href="https://hualei.online">hualei.online</a>。</p><hr><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>原主题特性</strong>:</p><ul><li><p>简单漂亮，文章内容美观易读</p></li><li><p><a href="https://material.io/" target="_blank" rel="noopener">Material Design</a> 设计</p></li><li><p>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</p></li><li><p>首页轮播文章及每天动态切换 <code>Banner</code> 图片</p></li><li><p>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</p></li><li><p>时间轴式的归档页</p></li><li><p><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</p></li><li><p>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</p></li><li><p>可自定义的数据的友情链接页面</p></li><li><p>支持文章置顶和文章打赏</p></li><li><p>支持 <code>MathJax</code></p></li><li><p><code>TOC</code> 目录</p></li><li><p>可设置复制文章内容时追加版权信息</p></li><li><p>可设置阅读文章时做密码验证</p></li><li><p><a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk</a>、<a href="https://imsun.github.io/gitment/" target="_blank" rel="noopener">Gitment</a>、<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a> 和 <a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</p></li><li><p>集成了<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</p></li><li><p>支持在首页的音乐播放和视频播放功能</p><p><strong>增加的工作或特性(未打钩的是已做但还没更新到源码的)</strong>:</p></li><li><p>修改了原主题的一些很多<code>bug</code>   2019.08.05</p></li><li><p>加入图片懒加载功能，在根目录配置文件开启和关闭    2019.08.09</p></li><li><p>增加<code>留言板</code>功能          2019.08.05</p></li><li><p>在关于板块,加入<code>简历</code>功能页   2019.08.05</p></li><li><p>增加视听[视觉听觉影音]板块       2019.08.10</p></li><li><p>支持<code>emoji</code>表情，用<code>markdown emoji</code>语法书写直接生成对应的能<strong>跳跃</strong>的表情。  2019.08.10</p></li><li><p>增加网站运行时间显示  2019.08.10</p></li><li><p>增加<code>动漫模型</code>     2019.08.10</p></li><li><p>整体替换Banner图片和文章特色图片   2019.08.10</p></li><li><p>增加分类<code>相册</code>功能         2019.08.29</p></li><li><p>去掉标签页,将其合并至<code>分类</code>页中                2019.09.01</p></li><li><p>修改了一些控件的参数   2019.09.01</p></li><li><p>修改部分样式,比如: 文章卡片,固定高度,使其不至于因为文章摘要的长短不同导致卡片大小不一使页面布局很不美观,类似的还有友链卡片,优化了页面内容布局,视觉更整齐美观          2019.09.01</p></li><li><p>解决首页文章列表卡片上方 <code>border-radius</code>圆角失效的bug  2019.09.01</p></li><li><p>添加页面樱花飘落动效            2019.09.09</p></li><li><p>添加鼠标点击烟花爆炸动效   2019.09.09</p></li><li><p>加入天气接口控件   2019.09.09</p></li><li><p>加入鼠标点击文字特效   2019.09.10</p></li><li><p>添加页面雪花飘落动效            2019.09.10</p></li><li><p>添加在线聊天插件            2019.09.12</p></li><li><p>持续更新…</p></li></ul><hr><blockquote><p><strong>更多详情教程，强烈推荐大佬写的：<a href="https://sunhwee.com/posts/6e8839eb.html" target="_blank" rel="noopener">Hexo+Github博客搭建完全教程</a></strong></p></blockquote><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://hualei.online/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://hualei.online/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://hualei.online/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件安装与配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
